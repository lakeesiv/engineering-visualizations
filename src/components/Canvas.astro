---
---

<div style="display: flex; flex-direction: row;">
  <canvas id="unit_circle" width="400" height="400"></canvas>
  <div id="my_dataviz"></div>
</div>
<button id="sweep">Sweep</button>

<script is:inline src="https://cdn.plot.ly/plotly-2.17.1.min.js"></script>
<script>
  const canvas = document.getElementById("unit_circle") as HTMLCanvasElement;
  const ctx = canvas.getContext("2d") as CanvasRenderingContext2D;
  const _canvasOffset = canvas.getBoundingClientRect();
  const offsetX = _canvasOffset.left;
  const offsetY = _canvasOffset.top;
  const TwoPI = Math.PI * 2;

  type Coordinate = [number, number];
  type ListOfCoordinates = Coordinate[];
  type Trace = {
    x: number[];
    y: number[];
    mode: "markers";
    type: "scattergl" | "scatter";
  };
  type ExtendedWindow = Window &
    typeof globalThis & {
      Plotly: any; // cba to add types
    };

  let poles: ListOfCoordinates = [
    [1, 0],
    [0, 0],
  ];
  let zeros: ListOfCoordinates = [
    [-1, 0],
    // [0, 0.5],
  ];

  const magnitudeAndArg = (coord: Coordinate) => {
    const [x, y] = coord;
    const magnitude = Math.sqrt(x * x + y * y);
    const arg = Math.atan2(y, x);
    return [magnitude, arg];
  };

  // find the poles where the magnitude is > 0.8
  let dangerAngles = poles.map((pole) => {
    const [magnitude, arg] = magnitudeAndArg(pole);
    if (magnitude > 0.8) {
      return arg;
    }
  });

  var NyquistTrace: Trace = {
    x: [],
    y: [],
    mode: "markers",
    type: "scatter",
  };

  const unitCircleCentreX = 200;
  const unitCircleCentreY = 200;
  const unitCircleRadius = 100;
  const unitCircleBorderColor = "black";
  const knobRadius = 5;
  const knobColor = "yellow";

  DrawFrame(unitCircleCentreX, unitCircleCentreY); // just to get started

  function DrawTargets(
    x: number,
    y: number,
    varient: "Pole" | "Zero",
    width = 5,
    lineWidth = 2,
    color = "red"
  ) {
    switch (varient) {
      case "Pole":
        ctx.beginPath();
        ctx.moveTo(x - width, y - width);
        ctx.lineTo(x + width, y + width);
        ctx.moveTo(x + width, y - width);
        ctx.lineTo(x - width, y + width);
        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = "blue";
        ctx.stroke();
        break;
      case "Zero":
        ctx.beginPath();
        ctx.arc(x, y, width, 0, TwoPI, false);
        ctx.fillStyle = "red";
        ctx.fill();
        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = "red";
        ctx.stroke();
        break;
    }
  }

  function DrawFrame(mouseX: number, mouseY: number, angleOverride?: number) {
    let angle =
      angleOverride ||
      Math.atan2(mouseY - unitCircleCentreY, mouseX - unitCircleCentreX);

    let poleCoords: ListOfCoordinates =
      poles.length > 0
        ? poles.map((pole) => {
            const x = pole[0] * unitCircleRadius + unitCircleCentreX;
            const y = -pole[1] * unitCircleRadius + unitCircleCentreY; // cba to figure out why this is negative
            return [x, y];
          })
        : [];

    let zeroCoords: ListOfCoordinates =
      zeros.length > 0
        ? zeros.map((zero) => {
            const x = zero[0] * unitCircleRadius + unitCircleCentreX;
            const y = -zero[1] * unitCircleRadius + unitCircleCentreY;
            return [x, y];
          })
        : [];

    let knobX = unitCircleRadius * Math.cos(angle) + unitCircleCentreX;
    let knobY = unitCircleRadius * Math.sin(angle) + unitCircleCentreY;

    // start drawing
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // draw circle
    ctx.beginPath();
    ctx.arc(
      unitCircleCentreX,
      unitCircleCentreY,
      unitCircleRadius,
      0,
      TwoPI,
      false
    );

    ctx.lineWidth = 2;
    ctx.strokeStyle = unitCircleBorderColor;
    ctx.stroke();

    // draw knob
    ctx.beginPath();
    ctx.arc(knobX, knobY, knobRadius, 0, TwoPI, false);
    ctx.fillStyle = knobColor;
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.strokeStyle = "black";
    ctx.stroke();

    let nyquistMagnitude = 1;
    let nyquistAngle = 0;

    poleCoords.forEach((pole) => {
      DrawTargets(pole[0], pole[1], "Pole");
      // draw a line from the pole to the indicator
      ctx.beginPath();
      ctx.moveTo(pole[0], pole[1]);
      ctx.lineTo(knobX, knobY);
      ctx.lineWidth = 2;
      ctx.strokeStyle = "red";
      ctx.stroke();
      // calculate the length of the line
      const dx = -pole[0] + knobX;
      const dy = pole[1] - knobY;
      const length = Math.sqrt(dx * dx + dy * dy);
      // calculate the angle between the line and the indicator
      const poleAngle = Math.atan2(dy, dx);

      // draw pole angle arc
      ctx.beginPath();
      ctx.arc(pole[0], pole[1], 20, 0, -poleAngle, poleAngle > 0);
      ctx.moveTo(pole[0], pole[1]);
      ctx.lineTo(pole[0] + 20, pole[1]);
      ctx.stroke();

      ctx.lineWidth = 2;
      ctx.strokeStyle = "red";
      ctx.stroke();

      nyquistAngle -= poleAngle;

      nyquistMagnitude /= length;
    });

    zeroCoords.forEach((zero) => {
      DrawTargets(zero[0], zero[1], "Zero");
      // draw a line from the pole to the indicator
      ctx.beginPath();
      ctx.moveTo(zero[0], zero[1]);
      ctx.lineTo(knobX, knobY);
      ctx.lineWidth = 2;
      ctx.strokeStyle = "blue";
      ctx.stroke();
      // calculate the length of the line
      const dx = -zero[0] + knobX;
      const dy = zero[1] - knobY;
      const length = Math.sqrt(dx * dx + dy * dy);
      // calculate the angle between the line and the indicator
      const zeroAngle = Math.atan2(dy, dx);

      ctx.beginPath();
      ctx.arc(zero[0], zero[1], 20, 0, -zeroAngle, zeroAngle > 0);
      ctx.moveTo(zero[0], zero[1]);
      ctx.lineTo(zero[0] + 20, zero[1]);
      ctx.stroke();

      nyquistAngle += zeroAngle;

      nyquistMagnitude *= length;
    });

    DrawTargets(unitCircleCentreX, unitCircleCentreY, "Zero", 2, 2, "blue"); // draw the origin

    const nyquistX = nyquistMagnitude * Math.cos(nyquistAngle);
    const nyquistY = nyquistMagnitude * Math.sin(nyquistAngle);
    const nyquistTheta = -angle;

    NyquistTrace.x.push(nyquistX);
    NyquistTrace.y.push(nyquistY);

    (window as ExtendedWindow).Plotly.newPlot("my_dataviz", [NyquistTrace]);
  }

  function handleMouseDown(e: MouseEvent) {
    let MouseX = e.clientX - offsetX;
    let MouseY = e.clientY - offsetY;

    DrawFrame(MouseX, MouseY);
  }

  let down = false;
  canvas.addEventListener("mousedown", (e) => {
    down = true;
  });
  canvas.addEventListener("mousemove", (e) => down && handleMouseDown(e));
  canvas.addEventListener("mouseup", (e) => (down = false));
  // if sweep button is clicked, sweep the knob

  const sweepButton = document.getElementById("sweep") as HTMLButtonElement;
  sweepButton.addEventListener("click", () => {
    let angle = 0;

    const interval = setInterval(() => {
      let inDangerZone = false;

      if (dangerAngles) {
        let delta = 10000;
        dangerAngles.forEach((a) => {
          if (a !== undefined) {
            let correctedAngle = angle;
            if (Math.abs(angle) > Math.PI) {
              correctedAngle = angle - Math.sign(angle) * 2 * Math.PI;
            }

            delta = Math.min(
              delta,
              Math.abs(Math.abs(correctedAngle) - Math.abs(a))
            );
          }
        });

        if (delta < 0.25) {
          inDangerZone = true;
        }
      }
      const increment = inDangerZone ? 0.005 : 0.05;

      DrawFrame(0, 0, angle);
      angle -= increment;
      console.log(angle);
      if (Math.abs(angle) > TwoPI) {
        clearInterval(interval);
      }
    }, 0.0001);
  });
</script>
